# -*- coding: utf-8 -*-
"""KG from pdf.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Nk7Q6Kupl6jazQWdMzhktIMSmAPNG_fc
"""

import torch
from transformers import BertTokenizer, BertForTokenClassification
import networkx as nx
import pdfplumber

class TextToKG:
    def __init__(self, spert_model_name="spert/spert"):
        # Load the SpERT model and tokenizer
        self.tokenizer = BertTokenizer.from_pretrained(spert_model_name)
        self.model = BertForTokenClassification.from_pretrained(spert_model_name)

    @staticmethod
    def extract_text_from_pdf(pdf_file):
        """
        Extracts text from a given PDF file.
        """
        with pdfplumber.open(pdf_file) as pdf:
            all_text = ""
            for page in pdf.pages:
                all_text += page.extract_text() + "\n"
        return all_text

    def extract_entities_and_relations(self, text):
        """
        Extracts entities and relationships from the text using SpERT.
        """
        tokens = self.tokenizer(text, return_tensors="pt", padding=True, truncation=True)
        outputs = self.model(**tokens)
        logits = outputs.logits
        predictions = torch.argmax(logits, dim=-1).squeeze().tolist()

        # Decode predictions to extract entities and relations
        decoded_tokens = self.tokenizer.convert_ids_to_tokens(tokens["input_ids"].squeeze())
        entities = []
        relations = []
        current_entity = None

        for token, pred in zip(decoded_tokens, predictions):
            if pred == 1:  # Start of an entity
                if current_entity:
                    entities.append(current_entity)
                current_entity = token
            elif pred == 2 and current_entity:  # Inside an entity
                current_entity += " " + token
            elif pred == 0 and current_entity:  # Outside an entity
                entities.append(current_entity)
                current_entity = None

        # Mocked relationships (replace with model output for real use cases)
        for i in range(len(entities) - 1):
            relations.append((entities[i], entities[i + 1], "related_to"))

        return entities, relations

    def generate_knowledge_graph(self, text_corpus):
        """
        Generates a knowledge graph from the text corpus.
        """
        all_entities = set()
        all_relations = []

        for text in text_corpus:
            entities, relations = self.extract_entities_and_relations(text)
            all_entities.update(entities)
            all_relations.extend(relations)

        G = nx.DiGraph()
        G.add_nodes_from(all_entities)
        G.add_edges_from([(rel[0], rel[1], {"relation": rel[2]}) for rel in all_relations])
        return G